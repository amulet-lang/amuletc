fn List -> type = (comptime 'a: type) do
    record {
        pub const t = record {
            const Self = @this()

            val: 'a,
            next: @option(Self)
        }

        pub fn new -> t = (val: 'a) do
            t.{ val, next = none }
        end

        pub fn (mut self: t).push = (val: 'a) do
            if self.next do
                let mut current = self.next
                while current.next do
                    current = current.next
                end

                current.next = t.new(val)
            else do
                self.next = t.new(val)
            end
        end
    }
end

fn main = () do
    let mut list = List(isize).new(12)
    list.push(16)

    @printf("List: [{}, {}]\n", {list.val, list.next.?.val})
end
