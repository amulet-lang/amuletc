const string = @import("std").string

fn Result -> type = (comptime success: type) {
    variant {
        Ok(success),
        Err(std.Error) // predefined interface
    }
}

const parseError = variant {
    invalidUTF8
}

// Implement the methods required by the Error interface
fn (err: &parseError).msg      -> string = () {/* */}
fn (err: &parseError).location -> string = () {/* */}
fn (err: &parseError).kind     -> string = () {/* */}
fn (err: &parseError).severity -> severity = () {/* */}

fn parse -> !isize = (str: string) {
    let word = /* */
    if word {
        /* */
    } else {
        return Err <| parseError.invalidUTF8
    }
}

fn main -> !unit = () {
    let str: string = "Hello"
    let result = parse(str[..]).!
    @print("result: {d}\n", {result})
}
