const List -> module = (comptime 'a: type) do
    module {
        pub const t = record {
            const Self = ruka.this()

            val: 'a,
            next: Option <| Self
        }

        pub const new -> t = (val: 'a) do
            t.{
                val,
                next = None
            }
        end

        pub const push(mut self: &t) = (val: 'a) do
            if self.next == None do
                sself.next = Some <| t.new(val)
            else do
                let mut current = self.next
                while current.next != None do
                    current = current.next
                end

                current.next = Some <| t.new(val)
            end
        end
    }
end

const main = () do
    const IntList = List(int)
    let mut list = IntList.new(12)
    list.push(16)

    /* can also alias a modules when using it to simplify usages without importing it's symbols
        use List(int) as List

        let mut list = List.new(12)
        list.push(16)
    */
    ruka.println("List: [{}, {}]", {list.val, list.next.val})
end
