fn List -> type = (comptime 'a: type) {
    record {
        pub const t = record {
            const Self = @this()

            val: 'a,
            next: Option <| Self
        }

        pub fn new -> t = (val: 'a) {
            t.{ val, next = None }
        }

        pub fn (mut self: &t).push = (val: 'a) {
            if self.next {
                let mut current = self.next
                while current.next {
                    current = current.next
                }

                current.next = Some <| t.new(val)
            } else {
                self.next = Some <| t.new(val)
            }
        }
    }
}

fn main = () {
    let mut list = List(int).new(12)
    list.push(16)

    @print("List: [{}, {}]\n", {list.val, list.next.!.val})
}
