use std;

const List -> module = (comptime 'a: type) do
    module {
        pub const t = record {
            const Self = warp.this();

            val: 'a,
            next: Option <| Box(Self)
        }

        pub const new -> t = (val: 'a) do
            t.{
                val,
                next = None
            }
        end

        pub const push = (list: mut &t, val: 'a) do
            if list == None do
                list = Some <| Box(t).new(val);
            else if list.next == None do
                list.next = Some <| Box(t).new(val);
            else do
                let mut current = list.next;
                while current.next != None do
                    current = current.next;
                end

                current.next = Some <| Box(t).new(val);
            end
        end
    }
end

const main = () do
    const IntList = List(int);
    let mut list: IntList.t = IntList.new(12);

    // Functions called like methods will search within the module the type belongs to
    // if no candidate exists in the current scope, so no use statement is needed
    list.push(16);

    /* Could also use a use statement, which expose symbols with the current scope
        use List(int).*; 

        let mut list = new(12);
        push(mut& list, 16);
        list.push(16);
    */
    /* can also alias a modules when using it to simplify usages without importing it's symbols
        use List(int) as List; 

        let mut list = List.new(12);
        list.push(16);
    */
    std.io.println("List: [{}, {}]", .{list.val, list.next.val});
end
