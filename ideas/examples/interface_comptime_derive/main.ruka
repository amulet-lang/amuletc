const Num = interface ('a) {
    (+)(&): (rhs: &'a) -> 'a
}

const num = fn -> module (comptime 'a: type) {
    module {
        pub const t = 'a;

        pub const (+) = fn -> t (lhs: &t, rhs: &t) {
            let mut result = t.{}

            inline for f in @type_info(t).fields {
                @field(result, f) = @field(lhs, f) + @field(rhs, f)
            }
        }
    }
}

const Vector = record {x: int, y: int} 
    |> num() 
    |> @member(:t)

const add = fn -> Num (x, y: Num) {
    x + y
}

const main = fn -> Result(unit) () {
    let a = Vector.{.x = 10, .y = 5}
    let b = Vector.{.x = 5, .y = 10}
    let c = a + b

    @assert(c.x == 15 and c.y == 15)?

    let d = 10
    let e = 5
    let f = add(d, e)

    @assert(f == 15)?

    Ok <| ()
}
