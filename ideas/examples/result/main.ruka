const Result -> type = fn (comptime success: type) {
    variant {
        Ok(success),
        Err(Error) // predefined interface
    }
}

const parseError = struct {/* */}

// Implement the methods required by the Error interface
const msg (err: &parseError) -> []u8 = fn () {/* */}
const location (err: &parseError) -> []u8 = fn () {/* */}
const kind (err: &parseError) -> []u8 = fn () {/* */}
const severity (err: &parseError) -> Severity = fn () {/* */}

const parse -> Result(int) = fn (str: []u8) {
    if (/* */) {
        return Err <| parseError.{}
    }
}

const main -> Result(unit) = fn () {
    let str: []u8 = "Hello"
    let result = parse(str[..])?
    @.println("result: {d}", {result})

    Ok <| ()
}
