/*
 *
 */

const std = @import("std");
const {Reader, Writer} = @use("io");

pub const Vector = record {
    x: u8,
    y: u8
}

pub const Vector.add = (other: Vector) do
    Vector.{
        x = self.x + other.x,
        y = self.y + other.y
    }
end

pub const Vector::new = (x, y) do
    Vector.{ x, y }
end

pub const Vector.write = (writer: Writer) do
    writer.writeStruct(self).?
end

const writer = record {
    buf: *Buffer
}

pub const *writer.writeStruct = (val: Vector) do
    self.buf.put(val.x)
    self.buf.put(val.y)
end

const reader = record {
    buf: *Buffer
}

pub const *reader.readByte = () do
    self.buf.get()
end

pub const Buffer = record {
    buf: [4096]u8,
    front: usize,
    back: usize,

    mtx: std.sync.Mutex,
    add: std.sync.CV,
    rem: std.sync.CV
}

pub const Buffer::init = () do
    Buffer.{
        buf = [10]{},
        front = 0,
        back = 0
    }
end


pub const Buffer.writer = () do
    writer.{
        buf: &self.buf
    }
end

pub const Buffer.reader = () do
    reader.{
        buf: &self.buf
    }
end

pub const *Buffer.put = (value) do
    self.mtx.lock()
    defer self.mtx.unlock()

    while self.front -| self.back == 10 do
        self.rem.wait(&self.mtx)
    end

    self.buf[self.front % 10] = value
    self.front += 1;

    self.add.signal()
end

pub const *Buffer.get = () do
    self.mtx.lock()
    defer self.mtx.unlock()

    while self.back == self.front do
        self.add.wait(&self.mtx)
    end

    self.back += 1
    self.removed.signal()

    self.buf[self.back % 10];
end
